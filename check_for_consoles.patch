diff --git a/src/main.c b/src/main.c
index e4223b7..c85fe4c 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1872,14 +1872,16 @@ add_display_and_keyboard_for_console (const char *console,
   add_display_and_keyboard_for_terminal (state, terminal);
 }
 
-static bool
+static int
 add_consoles_from_file (state_t         *state,
                         ply_hashtable_t *consoles,
                         const char      *path)
 {
   int fd;
   char contents[512] = "";
-  const char *remaining_command_line;
+  ssize_t contents_length;
+  int num_consoles;
+  const char *remaining_file_contents;
   char *console;
 
   ply_trace ("opening %s", path);
@@ -1888,60 +1890,86 @@ add_consoles_from_file (state_t         *state,
   if (fd < 0)
     {
       ply_trace ("couldn't open it: %m");
-      return false;
+      return 0;
     }
 
   ply_trace ("reading file");
-  if (read (fd, contents, sizeof (contents)))
+  contents_length = read (fd, contents, sizeof (contents));
+
+  if (contents_length <= 0)
     {
       ply_trace ("couldn't read it: %m");
       close (fd);
-      return false;
+      return 0;
     }
   close (fd);
 
-  remaining_command_line = contents;
+  remaining_file_contents = contents;
+  num_consoles = 0;
 
   console = NULL;
-  while (remaining_command_line != '\0')
+  while (remaining_file_contents < contents + contents_length)
     {
-      char *end;
       size_t console_length;
+      char *end;
       char *console_device;
 
-      state->should_force_details = true;
+      /* Advance past any leading whitespace */
+      remaining_file_contents += strspn (remaining_file_contents, " \n\t\v");
 
-      console = strdup (remaining_command_line);
+      if (*remaining_file_contents == '\0')
+        {
+          /* There's nothing left after the whitespace, we're done */
+          break;
+        }
 
-      end = strpbrk (console, " \n\t\v");
+      console = strdup (remaining_file_contents);
 
-      if (end != NULL)
-        *end = '\0';
+      /* Find trailing whitespace and NUL terminate.  If strcspn
+       * doesn't find whitespace, it gives us the length of the string
+       * until the next NUL byte, which we'll just overwrite with
+       * another NUL byte anyway. */
+      console_length = strcspn (console, " \n\t\v");
+      console[console_length] = '\0';
 
-      console_length = strlen (console);
+      /* If this console is anything besides tty0, then the user is sort
+       * of a weird case (uses a serial console or whatever) and they
+       * most likely don't want a graphical splash, so force details.
+       */
+      if (strcmp (console, "tty0") != 0)
+        state->should_force_details = true;
 
       asprintf (&console_device, "/dev/%s", console);
       free (console);
       console = NULL;
 
       ply_trace ("console %s found!", console_device);
       ply_hashtable_insert (consoles, console_device, console_device);
-      remaining_command_line += console_length;
+      num_consoles++;
+
+      /* Move past the parsed console string, and the whitespace we
+       * may have found above.  If we found a NUL above and not whitespace,
+       * then we're going to jump past the end of the buffer and the loop
+       * will terminate
+       */
+      remaining_file_contents += console_length + 1;
     }
 
-  return true;
+  return num_consoles;
 }
 
-static void
+static int
 add_consoles_from_kernel_command_line (state_t         *state,
                                        ply_hashtable_t *consoles)
 {
   const char *console_string;
   const char *remaining_command_line;
   char *console;
+  int num_consoles;
 
   remaining_command_line = state->kernel_command_line;
 
+  num_consoles = 0;
   console = NULL;
   while ((console_string = command_line_get_string_after_prefix (remaining_command_line,
                                                                  "console=")) != NULL)
@@ -1977,8 +2003,11 @@ add_consoles_from_kernel_command_line (state_t         *state,
 
       ply_trace ("console %s found!", console_device);
       ply_hashtable_insert (consoles, console_device, console_device);
+      num_consoles++;
       remaining_command_line += console_length;
     }
+
+  return num_consoles;
 }
 
 static void
@@ -1988,33 +2017,47 @@ check_for_consoles (state_t    *state,
 {
   char *console;
   ply_hashtable_t *consoles;
+  int num_consoles;
+  bool ignore_serial_consoles;
 
   ply_trace ("checking for consoles%s",
              should_add_displays? " and adding displays": "");
 
   consoles = ply_hashtable_new (ply_hashtable_string_hash,
                                 ply_hashtable_string_compare);
+  ignore_serial_consoles = command_line_has_argument (state->kernel_command_line, "plymouth.ignore-serial-consoles");
+
+  num_consoles = 0;
 
-  if (!add_consoles_from_file (state,
-                               consoles,
-                               "/sys/class/tty/console/active"))
+  if (!ignore_serial_consoles)
     {
-      ply_trace ("falling back to kernel command line");
-      add_consoles_from_kernel_command_line (state, consoles);
+      num_consoles = add_consoles_from_file (state, consoles, "/sys/class/tty/console/active");
+
+      if (num_consoles == 0)
+        {
+          ply_trace ("falling back to kernel command line");
+          num_consoles = add_consoles_from_kernel_command_line (state, consoles);
+        }
+    }
+  else
+    {
+      ply_trace ("ignoring all consoles but default console because of plymouth.ignore-serial-consoles");
     }
 
   console = ply_hashtable_remove (consoles, (void *) "/dev/tty0");
   if (console != NULL)
     {
       free (console);
-      ply_hashtable_insert (consoles, (void *) default_tty, (char *) default_tty);
+      console = strdup (default_tty);
+      ply_hashtable_insert (consoles, console, console);
     }
 
   console = ply_hashtable_remove (consoles, (void *) "/dev/tty");
   if (console != NULL)
     {
       free (console);
-      ply_hashtable_insert (consoles, (void *) default_tty, (void *) default_tty);
+      console = strdup (default_tty);
+      ply_hashtable_insert (consoles, console, console);
     }
 
   free (state->kernel_console_tty);
@@ -2025,10 +2068,18 @@ check_for_consoles (state_t    *state,
 
   if (should_add_displays)
     {
-      ply_hashtable_foreach (consoles,
-                             (ply_hashtable_foreach_func_t *)
-                             add_display_and_keyboard_for_console,
-                             state);
+      /* Do a full graphical splash if there's no weird serial console
+       * stuff going on, otherwise just prepare text splashes
+       */
+      if ((num_consoles == 0) ||
+          ((num_consoles == 1) &&
+           (ply_hashtable_lookup (consoles, (void *) default_tty) != NULL)))
+        add_default_displays_and_keyboard (state);
+      else
+        ply_hashtable_foreach (consoles,
+                               (ply_hashtable_foreach_func_t *)
+                               add_display_and_keyboard_for_console,
+                               state);
     }
 
   ply_hashtable_foreach (consoles, (ply_hashtable_foreach_func_t *) free, NULL);
@@ -2036,8 +2087,6 @@ check_for_consoles (state_t    *state,
 
   ply_trace ("After processing serial consoles there are now %d text displays",
              ply_list_get_length (state->text_displays));
-  if (should_add_displays && ply_list_get_length (state->text_displays) == 0)
-    add_default_displays_and_keyboard (state);
 }
 
 static bool
